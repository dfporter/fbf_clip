"""
================
= The troubles. SOLVED.

CIMS.pl calls tags2cluster.pl with wrong format.

Specifically, running:
perl ../clip/CIMS/CIMS.pl -v novo_tags_collapse/runx_fbf_tggc_adapter_removed_no_barcode.bed mismatch_tags/runx_fbf_tggc_adapter_removed_no_barcode.bed out.test
 generates
CMD = CIMS.pl -v novo_tags_collapse/runx_fbf_tggc_adapter_removed_no_barcode.bed mismatch_tags/runx_fbf_tggc_adapter_removed_no_barcode.bed out.test
clustering mutation sites ...
# CIMS.pl calls tag2cluster.pl, which prints the following lines:
CMD=tag2cluster.pl -s -maxgap -1 -v mismatch_tags/runx_fbf_tggc_adapter_removed_no_barcode.bed ./CIMS.pl_1434903743_0.88872381889178/mutation.cluster.bed
# -s : same strand required. -maxgap : max gap considered as an overlap,
# set here to minus one.
# -v : verbose. The expected non-option arguments are <in.bed> and <out.bed>.
# The following line is output by tag2cluster.pl just before calling
# readBedFile (if not $bigFile) or splitBedFileByChrom:
reading tags from mismatch_tags/runx_fbf_tggc_adapter_removed_no_barcode.bed ...

# Line 112 of tag2cluster.pl is a call to readBedFile($in, $verbose).
# readBedFile is in Bed.pm. readBedFile passes each line to
# readNextBedLine, which skips lines starting with #, \s, track or browser,
# and otherwise calls lineToBed.
# lineToBed splits on \s (whitespace), and expects at least three columns
# of the following format:
# (chrom chromStart chromEnd name score strand thickStart thickEnd
# itemRgb blockCount blockSizes blockStarts);
# If blockSizes/blockStarts columns exist, some extra processing is done.
# The actual format of the mismatches file is:
# V	16502795	16502796
# HWI-D00256:355:H3KFTBCXX:1:1101:1673:2149#AGCTGGCCC
# 32	+	32	T	-	.	1
# Which is chrm, start, end, name, score, strand, as expected,
# and then diverges from the expected format. This leads to getting a 32
# for thickStart, a T for thickEnd, - for itemRgb, . for blockCount and
# 1 for blockSizes. Since a blockSizes column exists, it splits blockSizes
# by , and checks if this equals blockCount (which is .).
# This results in the crash and the observed error:
Argument "." isn't numeric in subtraction (-) at /groups/Kimble/Aman Prasad/clip/plib//Bed.pm line 271, <$fin> line 1.
incorrect number of blocks at line V	16502795	16502796	HWI-D00256:355:H3KFTBCXX:1:1101:1673:2149#AGCTGGCCC	32	+	32	T	-.	1
 at ../clip/CIMS/tag2cluster.pl line 112

# Some additional errors are then output:
counting the total tag number for each mutation site ...
CMD=tag2profile.pl -region ./CIMS.pl_1434903743_0.88872381889178/mutation.cluster.bed -ss -of bed -v novo_tags_collapse/runx_fbf_tggc_adapter_removed_no_barcode.bed ./CIMS.pl_1434903743_0.88872381889178/mutation.tagcount.bed
no chrLen.txt file specified
 at ../clip/CIMS/tag2profile.pl line 167
CMD=perl ../clip/CIMS/tag2profile.pl -region ./CIMS.pl_1434903743_0.88872381889178/mutation.cluster.bed -ss -of bed  -v novo_tags_collapse/runx_fbf_tggc_adapter_removed_no_barcode.bed ./CIMS.pl_1434903743_0.88872381889178/mutation.tagcount.bed failed: 512
reading frequency of mutations and tag number for each mutation site
cannot open file ./CIMS.pl_1434903743_0.88872381889178/mutation.cluster.bed to read
 at ../clip/CIMS/CIMS.pl line 133

# So clearly the mismatch tag file, which was generated by
# novoalign2bed.pl, is not in the expected format.
# However, the tags.bed file only has columns up to strand, and is properly
# clustered by tags2bed.pl. Running CIMS.pl with both input files as
# the collapsed tags file will generate ouptut and no errors.

# Examining the case of passing both arguments as the tags file, we see
# tag2cluster.pl is called to output a file:
# ./CIMS.pl_1434906668_0.0560365266437692/mutation.cluster.bed
# This file does not exist when the program exits.
# Running the command on its own:
../clip/CIMS/tag2cluster.pl -s -maxgap -1 -v \
    novo_tags_collapse/runx_fbf_tggc_adapter_removed_no_barcode.bed clustered_tags
# We get a file with the following format:
I       49342   49384   I_f_c0  1       +
I       49706   49774   I_f_c1  2       +
# It's probably safe to assume the score is the number of tags in the cluster.

# After that, CIMS.pl outputs:
counting the total tag number for each mutation site ...
CMD=tag2profile.pl -region ./CIMS.pl_1434906668_0.05603\
    65266437692/mutation.cluster.bed -ss -of bed \
    -v novo_tags_collapse/runx_fbf_tggc_adapter_removed\
    _no_barcode.bed ./CIMS.pl_1434906668_0.0560365266437\
    692/mutation.tagcount.bed
reading tags from novo_tags_collapse/runx_fbf_tggc_adapter_removed_no_barcode.bed ...
# Of course, the output file does not exist when CIMS.pl exits.
# tag2progile.pl is described to:
"Count tag numbers in sliding window or particular regions
    or each nucleotide position\n";
Usage: $prog [options] <in.bed> <profile.out> [profile.out.2]\n";
<in.bed> : gzip compressed Bed file with .gz extension is allowed\n";
         : use \"-\" for stdin\n"; 
<profile.out> [profile.out.2] : for wig format output, specify two \
    files to separate the two strands\n";
# -ss : separate strand. -of : output format.
# -region : $regionFile.
# So, in other words, it appears that tag2profile.pl is intended to
# count the tag numbers in the regions where mutations have occured.
# Running this program on its own:
-bash-4.1$ ../clip/CIMS/tag2profile.pl -region clustered_tags \
-ss -of bed -v novo_tags_collapse/runx_fbf_tggc_adapter_removed\
_no_barcode.bed mutation.tag.count
# Generates a file in this format:
I       49342   49384   I_f_c0  1       +
I       49706   49774   I_f_c1  2       +
I       91226   91268   I_f_c2  1       +
# Apparently the same as the clustered_tags file output by tag2cluster.pl.

# After tag2profile.pl, CIMS.pl executes the following:
generating random CIMS sites ...
perl ../clip/CIMS/simulateCLIPmismatch.pl -n 4019  \
    -srand 1.17082803610629 novo_tags_collapse/runx\
    _fbf_tggc_adapter_removed_no_barcode.bed \
    ./CIMS.pl_1434906668_0.0560365266437692/mutation.random.0.bed
# The mutation.random.0.bed files have the following format,
# if the sumulateCLIPmismatch.pl script is run on its own:
I       49362   49363   CIMS_0  0       +
I       49732   49733   CIMS_1  0       +

# After the simulation, CIMS.pl does the following:
clustering mutation sites in ./CIMS.pl_1434906668_0.0560365\
    266437692/mutation.random.4.bed ...
# This is generated from the following bit of code in CIMS.pl:
print "clustering mutation sites ...\n" if $verbose;
my $mutationClusterFile = "$cache/mutation.cluster.bed";
my $cmd = "perl $cmdDir/tag2cluster.pl  -s \
    -maxgap \"-1\" $bigFlag $verboseFlag $mutationBedFile $mutationClusterFile";
# $mutationBedFile is initially set to the second command line argument.
# $mutationClusterFile is the output from tag2cluster.pl being called
# on $mutationBedFile.

# Looking closer at what happens to $mutationBedFile,
# we note the -p option denotes that mutations in the mutation file are
# relative to the read start, which sets $trackPosition to True, which
# results in an attempt to adjust mutation positions to be relative to the
# chromStart. $mutationBedFile is first sorted by column 4 (the name,
# in a normal bed file), then column 4 is extracted to $mutationIdFile,
# and the following command is executed:
"python $cmdDir/joinWrapper.py $tagBedFile $mutationIdFile 4 1 N $tmpFile"
# joinWrapper.py will sort $tagBedFile by column 4 and $mutationIdFile by column 1.
# joinWrapper.py will then split the first line of $tagBedFile, and for
# each tab delimited column, build an option variable to be 1.1,1.,1.,
# extending to the length of the row. join is then called as:
join -f ' ' -o option -1 1 -2 4 sorted_file1 sorted_file2 > outfile
# man join gives the following description:
Join lines on a common field, writes to standard output a line for each
    pair of input lines that have identical join fields.
# The joining columns both have to be sorted.
# The -o parameter is given the following description:
     Construct each output line according to the format in FIELD-LIST.
     Each element in FIELD-LIST is either the single character `0' or
     has the form M.N where the file number, M, is `1' or `2' and N is
     a positive field number.
# CIMS.pl then does the following:
my $mutationNum = `wc -l $mutationIdFile | awk '{print \$1}'`; chomp $mutationNum;
my $tagNum = `wc -l $tmpFile | awk '{print \$1}'`; chomp $tmpFile;
# Then checks if the lengths match.

# Note that joinWrapper.py is called with the tagBedFile and mutationIdFiles,
# and will lead to a file of a different length if the read names don't correspond
# exactly.
# If the file lengths are the same, CIMS.pl proceeds to generate a mutation
# position file, located at $cache/mutation.pos.txt:
paste mismatch_tags/runx_fbf_tggc_adapter_removed_no_barcode.bed \
tmpFile | awk '{if($6 =="+") {print $5;} else {print $9-$8-$5-1}}' > mutationPositionFile
# This produces a single column of output for $cache/mutation.pos.txt.

# The remaining output from CIMS.pl:
counting the total tag number for each clustered mutation site in \
    ./CIMS.pl_1434906668_0.0560365266437692/mutation.random.4.cluster.bed ...
reading frequency of mutations and tag number for each mutation site
find cummulative distributions ...
correcting FDRs for sparse sampling ...
writing output to out.test ...

================
= The solution.

# So apparently both the mutation and tags files have the following format:
I       49342   49384   read_name  1       +
# The mutations file output by novoalign2bed.pl is in an irrelevant format.
# It was a red herring.
# We have to select one type of mutation from that file and generate a
# mutations bed file with the score being the location in the read of
# that mutation type. Those files are the two arguments to CIMS.pl.
# I've written the following program to do this:

python select_mutation_dfporter.py --mut AtoT <in.mismatch> <out.mismatch>

CIMS.pl will work correctly given this input.

"""
